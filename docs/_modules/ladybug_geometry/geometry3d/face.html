<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ladybug_geometry.geometry3d.face &#8212; ladybug geometry  documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          ladybug geometry</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ladybug_geometry.html">ladybug_geometry package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ladybug_geometry.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.html">ladybug_geometry.geometry2d package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.arc.html">ladybug_geometry.geometry2d.arc module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.line.html">ladybug_geometry.geometry2d.line module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.mesh.html">ladybug_geometry.geometry2d.mesh module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.pointvector.html">ladybug_geometry.geometry2d.pointvector module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.polygon.html">ladybug_geometry.geometry2d.polygon module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.ray.html">ladybug_geometry.geometry2d.ray module</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../ladybug_geometry.geometry2d.html#module-ladybug_geometry.geometry2d">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.html">ladybug_geometry.geometry3d package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.arc.html">ladybug_geometry.geometry3d.arc module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.face.html">ladybug_geometry.geometry3d.face module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.line.html">ladybug_geometry.geometry3d.line module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.mesh.html">ladybug_geometry.geometry3d.mesh module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.plane.html">ladybug_geometry.geometry3d.plane module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.pointvector.html">ladybug_geometry.geometry3d.pointvector module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.polyface.html">ladybug_geometry.geometry3d.polyface module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.ray.html">ladybug_geometry.geometry3d.ray module</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../ladybug_geometry.geometry3d.html#module-ladybug_geometry.geometry3d">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ladybug_geometry.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ladybug_geometry.intersection2d.html">ladybug_geometry.intersection2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ladybug_geometry.intersection3d.html">ladybug_geometry.intersection3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ladybug_geometry.html#module-ladybug_geometry">Module contents</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ladybug_geometry.html">ladybug_geometry package</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-4">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ladybug_geometry.html">ladybug_geometry package</a></li>
</ul>

        </div>
      </div>
    <div class="body col-md-8 content" role="main">
      
  <h1>Source code for ladybug_geometry.geometry3d.face</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="sd">&quot;&quot;&quot;Planar Face in 3D Space&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">.pointvector</span> <span class="k">import</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Vector3D</span>
<span class="kn">from</span> <span class="nn">.ray</span> <span class="k">import</span> <span class="n">Ray3D</span>
<span class="kn">from</span> <span class="nn">.line</span> <span class="k">import</span> <span class="n">LineSegment3D</span>
<span class="kn">from</span> <span class="nn">.plane</span> <span class="k">import</span> <span class="n">Plane</span>
<span class="kn">from</span> <span class="nn">.mesh</span> <span class="k">import</span> <span class="n">Mesh3D</span>
<span class="kn">from</span> <span class="nn">._2d</span> <span class="k">import</span> <span class="n">Base2DIn3D</span>

<span class="kn">from</span> <span class="nn">..intersection3d</span> <span class="k">import</span> <span class="n">closest_point3d_on_line3d</span>

<span class="kn">from</span> <span class="nn">..geometry2d.pointvector</span> <span class="k">import</span> <span class="n">Point2D</span>
<span class="kn">from</span> <span class="nn">..geometry2d.ray</span> <span class="k">import</span> <span class="n">Ray2D</span>
<span class="kn">from</span> <span class="nn">..geometry2d.polygon</span> <span class="k">import</span> <span class="n">Polygon2D</span>
<span class="kn">from</span> <span class="nn">..geometry2d.mesh</span> <span class="k">import</span> <span class="n">Mesh2D</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>  <span class="c1"># python 3</span>
    <span class="n">xrange</span> <span class="o">=</span> <span class="nb">range</span>


<div class="viewcode-block" id="Face3D"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D">[docs]</a><span class="k">class</span> <span class="nc">Face3D</span><span class="p">(</span><span class="n">Base2DIn3D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Planar Face in 3D space.</span>

<span class="sd">    Args:</span>
<span class="sd">        boundary: A list or tuple of Point3D objects representing the outer</span>
<span class="sd">            boundary vertices of the face.</span>
<span class="sd">        plane: A Plane object indicating the plane in which the face exists.</span>
<span class="sd">            If None, the Plane normal will automatically be calculated by</span>
<span class="sd">            analyzing the input vertices and the origin of the plane will be</span>
<span class="sd">            the first vertex of the input vertices. Default: None.</span>
<span class="sd">        holes: Optional list of lists with one list for each hole in the face.</span>
<span class="sd">            Each hole should be a list of at least 3 Point3D objects.</span>
<span class="sd">            If None, it will be assumed that there are no holes in the face.</span>
<span class="sd">            The boundary and holes are stored as separate lists of Point3Ds on the</span>
<span class="sd">            `boundary` and `holes` properties of this object. However, the</span>
<span class="sd">            `vertices` property will always contain all vertices across the shape.</span>
<span class="sd">            For a Face3D that has holes, it will trace out a single shape that</span>
<span class="sd">            turns inwards from the boundary to cut out the holes.</span>
<span class="sd">        enforce_right_hand: Boolean to note whether a check should be run to</span>
<span class="sd">            ensure that input vertices are counterclockwise within the input plane,</span>
<span class="sd">            thereby enforcing the right-hand rule. By default, this is True</span>
<span class="sd">            and ensures that all Face3D objects adhere to the right-hand rule.</span>
<span class="sd">            It is recommended that this only be set to False in cases where you</span>
<span class="sd">            are certain that the input vertices are counter-clockwise</span>
<span class="sd">            within the input plane and you would like to avoid the extra</span>
<span class="sd">            unnecessary check.</span>

<span class="sd">    Properties:</span>
<span class="sd">        * vertices</span>
<span class="sd">        * plane</span>
<span class="sd">        * boundary</span>
<span class="sd">        * holes</span>
<span class="sd">        * polygon2d</span>
<span class="sd">        * boundary_polygon2d</span>
<span class="sd">        * hole_polygon2d</span>
<span class="sd">        * triangulated_mesh2d</span>
<span class="sd">        * triangulated_mesh3d</span>
<span class="sd">        * boundary_segments</span>
<span class="sd">        * hole_segments</span>
<span class="sd">        * normal</span>
<span class="sd">        * min</span>
<span class="sd">        * max</span>
<span class="sd">        * center</span>
<span class="sd">        * perimeter</span>
<span class="sd">        * area</span>
<span class="sd">        * centroid</span>
<span class="sd">        * is_clockwise</span>
<span class="sd">        * is_convex</span>
<span class="sd">        * is_self_intersecting</span>
<span class="sd">        * is_valid</span>
<span class="sd">        * has_holes</span>
<span class="sd">        * upper_left_counter_clockwise_vertices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_plane&#39;</span><span class="p">,</span> <span class="s1">&#39;_polygon2d&#39;</span><span class="p">,</span> <span class="s1">&#39;_mesh2d&#39;</span><span class="p">,</span> <span class="s1">&#39;_mesh3d&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_boundary&#39;</span><span class="p">,</span> <span class="s1">&#39;_holes&#39;</span><span class="p">,</span> <span class="s1">&#39;_boundary_segments&#39;</span><span class="p">,</span> <span class="s1">&#39;_hole_segments&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_boundary_polygon2d&#39;</span><span class="p">,</span> <span class="s1">&#39;_hole_polygon2d&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;_area&#39;</span><span class="p">,</span> <span class="s1">&#39;_centroid&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_is_convex&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_self_intersecting&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initilize Face3D.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the boundary and plane inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_vertices_input</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">Plane</span><span class="p">),</span> <span class="s1">&#39;Expected Plane for Face3D.&#39;</span> \
                <span class="s1">&#39; Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">plane</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane_from_vertices</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span> <span class="o">=</span> <span class="n">plane</span>

        <span class="c1"># process boundary and holes input</span>
        <span class="k">if</span> <span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">holes</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span> \
                <span class="s1">&#39;holes should be a tuple or list. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">holes</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_vertices_input</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="s1">&#39;hole&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes</span><span class="p">)</span>
            <span class="c1"># create a Polygon2D from the vertices</span>
            <span class="n">_boundary2d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">]</span>
            <span class="n">_holes2d</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes</span><span class="p">]</span>
            <span class="n">_polygon2d</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">from_shape_with_holes</span><span class="p">(</span><span class="n">_boundary2d</span><span class="p">,</span> <span class="n">_holes2d</span><span class="p">)</span>
            <span class="c1"># convert Polygon2D vertices to 3D to become the vertices of the face.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">_polygon2d</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="n">_polygon2d</span>

        <span class="c1"># perform a check of vertex orientation and enforce counter clockwise vertices</span>
        <span class="k">if</span> <span class="n">enforce_right_hand</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_clockwise</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="c1"># set other properties to None for now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh2d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh3d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_polygon2d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hole_polygon2d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_segments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hole_segments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Face3D.from_dict"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Face3D from a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: A python dictionary in the following format</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">            &quot;type&quot;: &quot;Face3D&quot;,</span>
<span class="sd">            &quot;boundary&quot;: [(0, 0, 0), (10, 0, 0), (0, 10, 0)],</span>
<span class="sd">            &quot;plane&quot;: {&quot;n&quot;: (0, 0, 1), &quot;o&quot;: (0, 0, 0), &quot;x&quot;: (1, 0, 0)},</span>
<span class="sd">            &quot;holes&quot;: [[(2, 2, 0), (5, 2, 0), (2, 5, 0)]]</span>
<span class="sd">            }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;holes&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;holes&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;holes&#39;</span><span class="p">])</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;plane&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;plane&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;plane&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]),</span>
                   <span class="n">plane</span><span class="p">,</span> <span class="n">holes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Face3D.from_extrusion"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.from_extrusion">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_extrusion</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">line_segment</span><span class="p">,</span> <span class="n">extrusion_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Face3D by extruding a line segment.</span>

<span class="sd">        Initializing a face this way has the added benefit of having its</span>
<span class="sd">        properties quickly computed.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_segment: A LineSegment3D to be extruded.</span>
<span class="sd">            extrusion_vector: A vector denoting the direction and distance to</span>
<span class="sd">                extrude the line segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_segment</span><span class="p">,</span> <span class="n">LineSegment3D</span><span class="p">),</span> \
            <span class="s1">&#39;line_segment must be LineSegment3D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line_segment</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrusion_vector</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">),</span> \
            <span class="s1">&#39;extrusion_vector must be Vector3D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">extrusion_vector</span><span class="p">))</span>
        <span class="n">_p1</span> <span class="o">=</span> <span class="n">line_segment</span><span class="o">.</span><span class="n">p1</span>
        <span class="n">_p2</span> <span class="o">=</span> <span class="n">line_segment</span><span class="o">.</span><span class="n">p2</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="p">(</span><span class="n">_p1</span><span class="p">,</span> <span class="n">_p2</span><span class="p">,</span> <span class="n">_p2</span> <span class="o">+</span> <span class="n">extrusion_vector</span><span class="p">,</span> <span class="n">_p1</span> <span class="o">+</span> <span class="n">extrusion_vector</span><span class="p">)</span>
        <span class="n">_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">line_segment</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">extrusion_vector</span><span class="p">),</span> <span class="n">_p1</span><span class="p">)</span>
        <span class="n">face</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_verts</span><span class="p">,</span> <span class="n">_plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_base</span> <span class="o">=</span> <span class="n">line_segment</span><span class="o">.</span><span class="n">length</span>
        <span class="n">_dist</span> <span class="o">=</span> <span class="n">extrusion_vector</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="n">_height</span> <span class="o">=</span> <span class="n">_dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">extrusion_vector</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">line_segment</span><span class="o">.</span><span class="n">v</span><span class="p">))</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">=</span> <span class="n">_base</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">_dist</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="n">_base</span> <span class="o">*</span> <span class="n">_height</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_centroid</span> <span class="o">=</span> <span class="n">_p1</span> <span class="o">+</span> <span class="p">(</span><span class="n">line_segment</span><span class="o">.</span><span class="n">v</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">extrusion_vector</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">face</span></div>

<div class="viewcode-block" id="Face3D.from_rectangle"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.from_rectangle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_rectangle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">base_plane</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Face3D from rectangle parameters (base + height) and a base plane.</span>

<span class="sd">        Initializing a face this way has the added benefit of having its</span>
<span class="sd">        properties quickly computed.</span>

<span class="sd">        Args:</span>
<span class="sd">            base: A number indicating the length of the base of the rectangle.</span>
<span class="sd">            height: A number indicating the length of the height of the rectangle.</span>
<span class="sd">            base_plane: A Plane object in which the rectangle will be created.</span>
<span class="sd">                The origin of this plane will be the lower left corner of the</span>
<span class="sd">                rectangle and the X and Y axes will form the sides.</span>
<span class="sd">                Default is the world XY plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)),</span> <span class="s1">&#39;Rectangle base must be a number.&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)),</span> <span class="s1">&#39;Rectangle height must be a number.&#39;</span>
        <span class="k">if</span> <span class="n">base_plane</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_plane</span><span class="p">,</span> <span class="n">Plane</span><span class="p">),</span> \
                <span class="s1">&#39;base_plane must be Plane. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">base_plane</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">_o</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">o</span>
        <span class="n">_b_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">base</span>
        <span class="n">_h_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">height</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="p">(</span><span class="n">_o</span><span class="p">,</span> <span class="n">_o</span> <span class="o">+</span> <span class="n">_b_vec</span><span class="p">,</span> <span class="n">_o</span> <span class="o">+</span> <span class="n">_h_vec</span> <span class="o">+</span> <span class="n">_b_vec</span><span class="p">,</span> <span class="n">_o</span> <span class="o">+</span> <span class="n">_h_vec</span><span class="p">)</span>
        <span class="n">face</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_verts</span><span class="p">,</span> <span class="n">base_plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="n">height</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_centroid</span> <span class="o">=</span> <span class="n">_o</span> <span class="o">+</span> <span class="p">(</span><span class="n">_b_vec</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">_h_vec</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">face</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">face</span></div>

<div class="viewcode-block" id="Face3D.from_regular_polygon"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.from_regular_polygon">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_regular_polygon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">side_count</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">base_plane</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Face3D from regular polygon parameters and a base_plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            side_count: An integer for the number of sides on the regular</span>
<span class="sd">                polgygon. This number must be greater than 2.</span>
<span class="sd">            radius: A number indicating the distance from the polygon&#39;s center</span>
<span class="sd">                where the vertices of the polygon will lie.</span>
<span class="sd">                The default is set to 1.</span>
<span class="sd">            base_plane: A Plane object for the plane in which the face exists.</span>
<span class="sd">                The origin of this plane will be used as the center of the polygon.</span>
<span class="sd">                If None, the default will be the WorldXY plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the default base_plane</span>
        <span class="k">if</span> <span class="n">base_plane</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_plane</span><span class="p">,</span> <span class="n">Plane</span><span class="p">),</span> <span class="s1">&#39;Expected Plane. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">base_plane</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># create the regular polygon face</span>
        <span class="n">_polygon2d</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">from_regular_polygon</span><span class="p">(</span><span class="n">side_count</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">_vert3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">base_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">_polygon2d</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">_face</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_vert3d</span><span class="p">,</span> <span class="n">base_plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># assign extra properties that we know to the face</span>
        <span class="n">_face</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="n">_polygon2d</span>
        <span class="n">_face</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">o</span>
        <span class="n">_face</span><span class="o">.</span><span class="n">_centroid</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">o</span>
        <span class="n">_face</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_face</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">_face</span></div>

<div class="viewcode-block" id="Face3D.from_punched_geometry"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.from_punched_geometry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_punched_geometry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base_face</span><span class="p">,</span> <span class="n">sub_faces</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a face with holes punched in it from sub-faces.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_face: A Face3D that acts as a parent to the sub_faces, completely</span>
<span class="sd">                encircling them.</span>
<span class="sd">            sub_faces: A list of Face3D objects that will be punched into the</span>
<span class="sd">                base_face. These faces must lie completely within the base_face</span>
<span class="sd">                for the result to be valid. The is_sub_face() method can be</span>
<span class="sd">                used to check sub_faces before they are input here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_face</span><span class="p">,</span> <span class="n">Face3D</span><span class="p">),</span> \
            <span class="s1">&#39;base_face should be a Face3D. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">base_face</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">sub_faces</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">Face3D</span><span class="p">),</span> \
                <span class="s1">&#39;sub_face should be a list. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">hole</span><span class="p">))</span>
        <span class="n">hole_verts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sub_faces</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">base_face</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">hole_verts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">base_face</span><span class="o">.</span><span class="n">holes</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base_face</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">base_face</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">hole_verts</span><span class="p">,</span>
                   <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of all vertices in this face.</span>

<span class="sd">        Note that, in the case of a face with holes, some vertices will be repeated</span>
<span class="sd">        since this property effectively traces out a single boundary around the</span>
<span class="sd">        whole shape, winding inward to cut out the holes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plane</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of all vertices in this face.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">polygon2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A Polygon2D of this face in the 2D space of the face&#39;s plane.</span>

<span class="sd">        Note that this is a single polygon object even when there are holes in the</span>
<span class="sd">        face since such a polygon can be made by drawing a line from the holes to</span>
<span class="sd">        the outer boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_vert2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="n">_vert2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">triangulated_mesh2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A triagulated Mesh2D in the 2D space of the face&#39;s plane.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh2d</span> <span class="o">=</span> <span class="n">Mesh2D</span><span class="o">.</span><span class="n">from_polygon_triangulated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh2d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">triangulated_mesh3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A triagulated Mesh3D of this face.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh3d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_vert3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">triangulated_mesh2d</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh3d</span> <span class="o">=</span> <span class="n">Mesh3D</span><span class="p">(</span><span class="n">_vert3d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangulated_mesh2d</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh3d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of vertices on the boundary of this face.</span>

<span class="sd">        For most Face3D objects, this will be identical to the vertices property.</span>
<span class="sd">        However, when the Face3D has holes within it, this property stores</span>
<span class="sd">        the outer boundary of the shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">holes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple with one tuple of vertices for each hole within this face.</span>

<span class="sd">        This property will be None when the face has no holes in it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of all line segments bordering the face.</span>

<span class="sd">        Note that this does not include segments for any holes in the face.</span>
<span class="sd">        Just the outer boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_segments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_segs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">):</span>
                <span class="n">_seg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert</span><span class="p">)</span>
                <span class="n">_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_seg</span><span class="p">)</span>
            <span class="n">_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_segs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># segments will start from the first vertex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_segments</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_segs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_segments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hole_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple with a tuple of line segments for each hole in the face.</span>

<span class="sd">        This will be None if there are no holes in the face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hole_segments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_all_segs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">_segs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hole</span><span class="p">):</span>
                    <span class="n">_seg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">hole</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert</span><span class="p">)</span>
                    <span class="n">_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_seg</span><span class="p">)</span>
                <span class="n">_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_segs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># segments will start from the first vertex</span>
                <span class="n">_all_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_segs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hole_segments</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span> <span class="k">for</span> <span class="n">_s</span> <span class="ow">in</span> <span class="n">_all_segs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hole_segments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary_polygon2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A Polygon2D of the face boundary in the 2D space of the face&#39;s plane.</span>

<span class="sd">        Note that this does not include any holes in the face. Just the outer boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_polygon2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_vert2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_polygon2d</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="n">_vert2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_polygon2d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hole_polygon2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of Polygon2D for the face holes in the 2D space of the face&#39;s plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hole_polygon2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hole_polygon2d</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">_vert2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hole_polygon2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon2D</span><span class="p">(</span><span class="n">_vert2d</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hole_polygon2d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normal vector for the plane in which the face exists.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The perimeter of the face. This includes the length of holes in the face.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hole_segments</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The area of the face.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">area</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The centroid of the face as a Point3D (aka. center of mass).</span>

<span class="sd">        Note that the centroid is more time consuming to compute than the center</span>
<span class="sd">        (or the middle point of the face bounding box). So the center might be</span>
<span class="sd">        preferred over the centroid if you just need a rough point for the middle</span>
<span class="sd">        of the face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_cent2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangulated_mesh2d</span><span class="o">.</span><span class="n">centroid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">_cent2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_clockwise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean for whether the face vertices and boundary are in clockwise order.</span>

<span class="sd">        Note that all Face3D objects should have counterclockwise vertices (meaning</span>
<span class="sd">        that this property should always be False). This property exists largely</span>
<span class="sd">        for testing / debugging purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_clockwise</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_convex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean noting whether the face is convex (True) or non-convex (False).</span>

<span class="sd">        Note that any face with holes will be automatically considered non-convex</span>
<span class="sd">        since the underlying polygon_2d is always non-convex in this case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_convex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_convex</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_convex</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_self_intersecting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean noting whether the face has self-intersecting edges.</span>

<span class="sd">        Note that this property is relatively computationally intense to obtain and</span>
<span class="sd">        most CAD programs forbid all surfaces with self-intersecting edges.</span>
<span class="sd">        So this property should only be used in quality control scripts where the</span>
<span class="sd">        origin of the geometry is unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_self_intersecting</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_self_intersecting</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean noting whether the face is valid (having a non-zero area).</span>

<span class="sd">        Note that faces are still considered valid if they have out-of-plane vertices,</span>
<span class="sd">        self-intersecting edges, or duplicate/colinear vertices. The check_planar</span>
<span class="sd">        method can be used to detect if there are out-of-plane vertices. The</span>
<span class="sd">        is_self_intersecting property identifies self-intersecting edges, and the</span>
<span class="sd">        remove_colinear_vertices method will remove duplicate/colinear vertices.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean noting whether the face has holes within it.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">upper_left_counter_clockwise_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this face&#39;s vertices starting from the upper left and moving counterclockwise.</span>

<span class="sd">        This is useful for getting the vertices of several faces aligned with the</span>
<span class="sd">        same global geometry rules for export to engines like EnergyPlus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># no vertex is above another</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="c1"># get a 2d polygon in the face plane that has a positive Y axis.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ref_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">o</span><span class="p">)</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ref_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span>
        <span class="c1"># get counterclockwise vertices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_clockwise</span><span class="p">:</span>
            <span class="n">verts3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
            <span class="n">verts2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verts3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
            <span class="n">verts2d</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span>
        <span class="c1"># sort points so that they start with the upper left point</span>
        <span class="n">corner_pt</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">polygon</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_pt_verts</span><span class="p">(</span><span class="n">corner_pt</span><span class="p">,</span> <span class="n">verts3d</span><span class="p">,</span> <span class="n">verts2d</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">upper_left_counter_clockwise_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get this face&#39;s boundary starting from the upper left and moving counterclockwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># no vertex is above another</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span>
        <span class="c1"># get a 2d polygon in the face plane that has a positive Y axis.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ref_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">o</span><span class="p">)</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ref_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
        <span class="c1"># get counterclockwise boundary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_clockwise</span><span class="p">:</span>
            <span class="n">verts3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">))</span>
            <span class="n">verts2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verts3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span>
            <span class="n">verts2d</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span>
        <span class="c1"># sort points so that they start with the upper left point</span>
        <span class="n">corner_pt</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">polygon</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_pt_verts</span><span class="p">(</span><span class="n">corner_pt</span><span class="p">,</span> <span class="n">verts3d</span><span class="p">,</span> <span class="n">verts2d</span><span class="p">)</span>

<div class="viewcode-block" id="Face3D.is_geometrically_equivalent"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.is_geometrically_equivalent">[docs]</a>    <span class="k">def</span> <span class="nf">is_geometrically_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a given face is geometrically equivalent to this Face.</span>

<span class="sd">        Geometrical equivalence is definied as being coplananar with this face,</span>
<span class="sd">        having the same number of vertices, and having each vertex map-able between</span>
<span class="sd">        the faces. Clockwise relationships do not have to match nor does the normal</span>
<span class="sd">        direction of the face.  However, all other properties must be matching to</span>
<span class="sd">        within the input tolerance.</span>

<span class="sd">        This is useful for identifying matching surfaces when solving for adjacency</span>
<span class="sd">        and you need to ensure that two faces match perfectly in their area and vertices.</span>
<span class="sd">        Note that you may also want to use the remove_colinear_vertices() method</span>
<span class="sd">        on input faces before using this method in order to count faces with the</span>
<span class="sd">        same non-colinear vertices as geometrically equivalent.</span>

<span class="sd">        Args:</span>
<span class="sd">            face: Another face for which geometric equivalency will be tested.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                vertices at which they can be considered geometrically equivalent.</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if geometrically equivalent. False if not geometrically equivalent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># rule out surfaces if they don&#39;t fit key criteria</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># see if we can find a matching vertex</span>
        <span class="n">match_i</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="n">match_i</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="c1"># check equivalency of each vertex</span>
        <span class="k">if</span> <span class="n">match_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">[</span><span class="n">match_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">match_i</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">[</span><span class="n">match_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">match_i</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Face3D.is_centered_adjacent"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.is_centered_adjacent">[docs]</a>    <span class="k">def</span> <span class="nf">is_centered_adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a given face is centered adjacent with this Face.</span>

<span class="sd">        Centered adjacency is definied as sharing the same center point as this face,</span>
<span class="sd">        sharing the same area, and being next to one another to within the tolerance.</span>

<span class="sd">        This is useful for identifying matching surfaces when you want to quickly</span>
<span class="sd">        solve for adjacency and you are not concerned about false positives in cases</span>
<span class="sd">        where one face does not perfectly match the other in terms of vertices.</span>
<span class="sd">        This means it is good enough for cases where users know how to set up their</span>
<span class="sd">        model correctly.</span>

<span class="sd">        Args:</span>
<span class="sd">            face: Another face for which centered adjacency will be tested.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                centers at which they can be considered centered adjacent.</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if centered adjacent. False if not centered adjacent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>  <span class="c1"># center check</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">-</span> <span class="n">face</span><span class="o">.</span><span class="n">area</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>  <span class="c1"># area check</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># construct a ray using this face&#39;s normal and a point just behind this face</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">move_vec</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span>  <span class="c1"># vector moving from the edge towards the center of Face</span>
            <span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">v2</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">v2</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">v2</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">move_vec</span> <span class="o">=</span> <span class="n">move_vec</span> <span class="o">*</span> <span class="p">(</span><span class="n">tolerance</span> <span class="o">+</span> <span class="mf">0.00001</span><span class="p">)</span>
        <span class="n">point_on_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">move_vec</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">test_ray</span> <span class="o">=</span> <span class="n">Ray3D</span><span class="p">(</span><span class="n">point_on_face</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="c1"># shoot ray from this face to the other to verify adjacency</span>
        <span class="k">if</span> <span class="n">face</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">test_ray</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Face3D.is_sub_face"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.is_sub_face">[docs]</a>    <span class="k">def</span> <span class="nf">is_sub_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a given face is a sub-face of this face.</span>

<span class="sd">        Sub-faces will lie in the same plane as this one and have all of their</span>
<span class="sd">        vertices completely within the boundary of this face.</span>

<span class="sd">        This is useful for identifying whether a given sub-face (ie. a window or door)</span>
<span class="sd">        can be assigned as a child to this face.</span>

<span class="sd">        Args:</span>
<span class="sd">            face: Another face for which sub-face equivalency will be tested.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                vertices at which they can be considered equivalent.</span>
<span class="sd">            angle_tolerance: The max angle in radians that the plane normals can</span>
<span class="sd">                differ from one another in order for them to be considered coplanar.</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if it is a possibe sub-face. False if it is not a valid sub-face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test whether the surface is coplanar</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">is_coplanar_tolerance</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># if it is, convert sub-face to a polygon in this face&#39;s plane</span>
        <span class="n">verts2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">face</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">sub_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="n">verts2d</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_polygon_inside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">is_polygon_inside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">hole_poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">hole_poly</span><span class="o">.</span><span class="n">is_polygon_outside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Face3D.check_planar"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.check_planar">[docs]</a>    <span class="k">def</span> <span class="nf">check_planar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that all of the face&#39;s vertices lie within the face&#39;s plane.</span>

<span class="sd">        This check is not done by default when creating the face since</span>
<span class="sd">        it is assumed that there is likely a check for planarity before the face</span>
<span class="sd">        is created (ie. in CAD software where the face likely originates from).</span>
<span class="sd">        This method is intended for quality control checking when the origin of</span>
<span class="sd">        face geometry is unkown or is known to come from a place where no</span>
<span class="sd">        planarity check was performed.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum distance between a given vertex and a the</span>
<span class="sd">                face&#39;s plane at which the vertex is said to lie in the plane.</span>
<span class="sd">            raise_exception: Boolean to note whether an exception should be raised</span>
<span class="sd">                if a vertex does not lie within the face&#39;s plane. If True, an</span>
<span class="sd">                exception message will be given in such cases, which notes the non-planar</span>
<span class="sd">                vertex and its distance from the plane. If False, this method will</span>
<span class="sd">                simply return a False boolean if a vertex is found that is out</span>
<span class="sd">                of plane. Default is True to raise an exception.</span>

<span class="sd">        Return:</span>
<span class="sd">            True if planar within the tolerance. False if not planar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_exception</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Vertex </span><span class="si">{}</span><span class="s1"> is out of plane with its parent face.</span><span class="se">\n</span><span class="s1">Distance &#39;</span>
                        <span class="s1">&#39;to plane is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">_v</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Face3D.remove_colinear_vertices"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.remove_colinear_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">remove_colinear_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a version of this face without colinear or duplicate vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the boundary segments</span>
<span class="sd">                at which point the vertex is considered colinear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">new_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">new_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_new_face</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_holes</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.flip"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a face with a flipped direction from this one.&quot;&quot;&quot;</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">flip</span><span class="p">(),</span>
                           <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfer_properties</span><span class="p">(</span><span class="n">_new_face</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">))</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.move"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a face that has been moved along a vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            moving_vec: A Vector3D with the direction and distance to move the face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">moving_vec</span><span class="p">)</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_transform</span><span class="p">(</span><span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">moving_vec</span><span class="p">)</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">moving_vec</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.rotate"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate a face by a certain angle around an axis and origin.</span>

<span class="sd">        Right hand rule applies:</span>
<span class="sd">        If axis has a positive orientation, rotation will be clockwise.</span>
<span class="sd">        If axis has a negative orientation, rotation will be counterclockwise.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis: A Vector3D axis representing the axis of rotation.</span>
<span class="sd">            angle: An angle for rotation in radians.</span>
<span class="sd">            origin: A Point3D for the origin around which the object will be rotated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_transform</span><span class="p">(</span><span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotate</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.rotate_xy"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.rotate_xy">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a face rotated counterclockwise in the world XY plane by a certain angle.</span>

<span class="sd">        Args:</span>
<span class="sd">            angle: An angle in radians.</span>
<span class="sd">            origin: A Point3D for the origin around which the object will be rotated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_transform</span><span class="p">(</span><span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotate_xy</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.reflect"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.reflect">[docs]</a>    <span class="k">def</span> <span class="nf">reflect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a face reflected across a plane with the input normal vector and origin.</span>

<span class="sd">        Args:</span>
<span class="sd">            normal: A Vector3D representing the normal vector for the plane across</span>
<span class="sd">                which the face will be reflected. THIS VECTOR MUST BE NORMALIZED.</span>
<span class="sd">            origin: A Point3D representing the origin from which to reflect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_transform_reflect</span><span class="p">(</span>
                <span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflect</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.scale"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale a face by a factor from an origin point.</span>

<span class="sd">        Args:</span>
<span class="sd">            factor: A number representing how much the face should be scaled.</span>
<span class="sd">            origin: A Point3D representing the origin from which to scale.</span>
<span class="sd">                If None, it will be scaled from the World origin (0, 0, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_transform_scale</span><span class="p">(</span>
            <span class="n">_verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">),</span> <span class="n">factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
            <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span></div>

<div class="viewcode-block" id="Face3D.intersect_line_ray"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.intersect_line_ray">[docs]</a>    <span class="k">def</span> <span class="nf">intersect_line_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_ray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the intersection between this face and the input Line3D or Ray3D.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_ray: A Line3D or Ray3D object for which intersection will be computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point3D for the intersection. Will be None if no intersection exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_plane_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">line_ray</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_plane_int</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_int2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_plane_int</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_point_inside_bound_rect</span><span class="p">(</span><span class="n">_int2d</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_plane_int</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Face3D.intersect_plane"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.intersect_plane">[docs]</a>    <span class="k">def</span> <span class="nf">intersect_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the intersection between this face and the input plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            plane: A Plane object for which intersection will be computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of LineSegment3D objects for the intersection.</span>
<span class="sd">            Will be None if no intersection exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_plane_int_ray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">intersect_plane</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_plane_int_ray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_p12d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_plane_int_ray</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="n">_p22d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_plane_int_ray</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">_plane_int_ray</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
            <span class="n">_v2d</span> <span class="o">=</span> <span class="n">_p22d</span> <span class="o">-</span> <span class="n">_p12d</span>
            <span class="n">_int_ray2d</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">_p12d</span><span class="p">,</span> <span class="n">_v2d</span><span class="p">)</span>
            <span class="n">_int_pt2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">intersect_line_infinite</span><span class="p">(</span><span class="n">_int_ray2d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_int_pt2d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_int_pt2d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># sort the points along the intersection line</span>
                    <span class="n">_int_pt2d</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pt</span><span class="p">:</span> <span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">_int_pt3d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">_int_pt2d</span><span class="p">]</span>
                <span class="n">_int_seg3d</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_int_pt3d</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">_int_seg3d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span>
                        <span class="n">_int_pt3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_int_pt3d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">_int_seg3d</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Face3D.project_point"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.project_point">[docs]</a>    <span class="k">def</span> <span class="nf">project_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project a Point3D onto this face.</span>

<span class="sd">        Note that this method does a check to see if the point can be projected to</span>
<span class="sd">        within this face&#39;s boundary. If all that is needed is a point projected</span>
<span class="sd">        into the plane of this face, the Plane.project_point() method should be</span>
<span class="sd">        used with this face&#39;s plane property.</span>

<span class="sd">        Args:</span>
<span class="sd">            point: A Point3D object to project.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point3D for the point projected onto this face. Will be None if the</span>
<span class="sd">            point cannot be projected to within the boundary of the face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_plane_int</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">o</span><span class="p">)</span>
        <span class="n">_plane_int2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">_plane_int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_point_inside_bound_rect</span><span class="p">(</span><span class="n">_plane_int2d</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_plane_int</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Face3D.get_mesh_grid"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.get_mesh_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_mesh_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">generate_centroids</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a gridded Mesh3D over this face.</span>

<span class="sd">        This method generates a mesh grid over the domain of the face</span>
<span class="sd">        and then removes any vertices that do not lie within it.</span>

<span class="sd">        Note that the x_dim and y_dim refer to dimensions within the X and Y</span>
<span class="sd">        coordinate system of this faces&#39;s plane. So rotating this plane will</span>
<span class="sd">        result in rotated grid cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_dim: The x dimension of the grid cells as a number.</span>
<span class="sd">            y_dim: The y dimension of the grid cells as a number. Default is None,</span>
<span class="sd">                which will assume the same cell dimension for y as is set for x.</span>
<span class="sd">            offset: A number for how far to offset the grid from the base face.</span>
<span class="sd">                Default is None, which will not offset the grid at all.</span>
<span class="sd">            flip: Set to True to have the mesh normals reversed from the direction</span>
<span class="sd">                of this face and to have the offset input move the mesh in the</span>
<span class="sd">                opposite direction from this face&#39;s normal.</span>
<span class="sd">            generate_centroids: Set to True to have the face centroids generated</span>
<span class="sd">                alongside the grid of vertices, which is much faster than having</span>
<span class="sd">                them generated upon request as they typically are. However, if you</span>
<span class="sd">                have no need for the face centroids, you would save time and memory</span>
<span class="sd">                by setting this to False. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the inputs and set defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_mesh_grid</span><span class="p">(</span><span class="n">x_dim</span><span class="p">,</span> <span class="s1">&#39;x_dim&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_mesh_grid</span><span class="p">(</span><span class="n">y_dim</span><span class="p">,</span> <span class="s1">&#39;y_dim&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_dim</span> <span class="o">=</span> <span class="n">x_dim</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_mesh_grid</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">)</span>

        <span class="c1"># generate the mesh grid and convert it to a 3D mesh</span>
        <span class="n">grid_mesh2d</span> <span class="o">=</span> <span class="n">Mesh2D</span><span class="o">.</span><span class="n">from_polygon_grid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">,</span> <span class="n">generate_centroids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vert_3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">grid_mesh2d</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_off_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">offset</span> <span class="k">if</span> <span class="n">flip</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">offset</span>
            <span class="n">_off_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">_off_num</span><span class="p">)</span>
            <span class="n">vert_3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_off_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">grid_mesh2d</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">grid_mesh3d</span> <span class="o">=</span> <span class="n">Mesh3D</span><span class="p">(</span><span class="n">vert_3d</span><span class="p">,</span> <span class="n">grid_mesh2d</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_face_areas</span> <span class="o">=</span> <span class="n">grid_mesh2d</span><span class="o">.</span><span class="n">_face_areas</span>

        <span class="c1"># assign the face plane normal to the mesh normals</span>
        <span class="k">if</span> <span class="n">flip</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_face_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_vertex_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">face</span><span class="p">))</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_faces</span><span class="p">)</span>  <span class="c1"># right-hand rule</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_face_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span>
            <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_vertex_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span><span class="o">.</span><span class="n">n</span>

        <span class="c1"># transform the centroids to 3D space if they were generated</span>
        <span class="k">if</span> <span class="n">generate_centroids</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">_conv_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plane</span> <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">_off_plane</span>
            <span class="n">grid_mesh3d</span><span class="o">.</span><span class="n">_face_centroids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_conv_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                                                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">grid_mesh2d</span><span class="o">.</span><span class="n">face_centroids</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid_mesh3d</span></div>

<div class="viewcode-block" id="Face3D.countour_by_number"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.countour_by_number">[docs]</a>    <span class="k">def</span> <span class="nf">countour_by_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour_count</span><span class="p">,</span> <span class="n">direction_vector</span><span class="o">=</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                           <span class="n">flip_side</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a list of LineSegment3D objects contouring the face.</span>

<span class="sd">        Args:</span>
<span class="sd">            contour_count: A positive integer for the number of contours</span>
<span class="sd">                to generate over the face.</span>
<span class="sd">            direction_vector: A Vector3D for the direction along which contours</span>
<span class="sd">                are generated. Default is Z-Axis, which generates horizontal contours.</span>
<span class="sd">            flip_side: Boolean to note whether the side the contours start from</span>
<span class="sd">                should be flipped. Default is False to have contours on top or right.</span>
<span class="sd">                Setting to True will start contours on the bottom or left.</span>
<span class="sd">            tolerance: An optional value to remove any contours with a length less</span>
<span class="sd">                than the tolerance. Default is 0, which will include all contours</span>
<span class="sd">                no matter how small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="n">direction_vector</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">tol_pt</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="mf">0.0000001</span><span class="p">,</span> <span class="mf">0.0000001</span><span class="p">,</span> <span class="mf">0.0000001</span><span class="p">)</span>
        <span class="n">diagonal</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="n">tol_pt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">-</span> <span class="n">tol_pt</span><span class="p">)</span>
        <span class="n">diagonal</span> <span class="o">=</span> <span class="n">diagonal</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span> <span class="k">if</span> <span class="n">flip_side</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="n">diagonal</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">diagonal</span><span class="o">.</span><span class="n">subdivide_evenly</span><span class="p">(</span><span class="n">contour_count</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect_plane</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">plane_normal</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">contours</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">contours</span> <span class="o">=</span> <span class="p">[</span><span class="n">l_seg</span> <span class="k">for</span> <span class="n">l_seg</span> <span class="ow">in</span> <span class="n">contours</span> <span class="k">if</span> <span class="n">l_seg</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">tolerance</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">contours</span></div>

<div class="viewcode-block" id="Face3D.countour_by_distance_between"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.countour_by_distance_between">[docs]</a>    <span class="k">def</span> <span class="nf">countour_by_distance_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">direction_vector</span><span class="o">=</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                     <span class="n">flip_side</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a list of LineSegment3D objects contouring the face.</span>

<span class="sd">        Args:</span>
<span class="sd">            distance: A number for the approximate distance between each contour.</span>
<span class="sd">                The actual distance will be computed from</span>
<span class="sd">            direction_vector: A Vector3D for the direction along which contours</span>
<span class="sd">                are generated. Default is Z-Axis, which generates horizontal contours.</span>
<span class="sd">            flip_side: Boolean to note whether the side the contours start from</span>
<span class="sd">                should be flipped. Default is False to have contours on top or right.</span>
<span class="sd">                Setting to True will start contours on the bottom or left.</span>
<span class="sd">            tolerance: An optional value to remove any contours with a length less</span>
<span class="sd">                than the tolerance. Default is 0, which will include all contours</span>
<span class="sd">                no matter how small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="n">direction_vector</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">tol_pt</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="mf">0.0000001</span><span class="p">,</span> <span class="mf">0.0000001</span><span class="p">,</span> <span class="mf">0.0000001</span><span class="p">)</span>
        <span class="n">diagonal</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="n">tol_pt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">-</span> <span class="n">tol_pt</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">direction_vector</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">diagonal</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="n">proj_dist</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">diagonal</span> <span class="o">=</span> <span class="n">diagonal</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span> <span class="k">if</span> <span class="n">flip_side</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="n">diagonal</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">diagonal</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="n">proj_dist</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect_plane</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">plane_normal</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">contours</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">contours</span> <span class="o">=</span> <span class="p">[</span><span class="n">l_seg</span> <span class="k">for</span> <span class="n">l_seg</span> <span class="ow">in</span> <span class="n">contours</span> <span class="k">if</span> <span class="n">l_seg</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">tolerance</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">contours</span></div>

<div class="viewcode-block" id="Face3D.countour_fins_by_number"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.countour_fins_by_number">[docs]</a>    <span class="k">def</span> <span class="nf">countour_fins_by_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fin_count</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                <span class="n">contour_vector</span><span class="o">=</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">flip_side</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a list of Fac3D objects over this face (like louvers or fins).</span>

<span class="sd">        Args:</span>
<span class="sd">            fin_count: A positive integer for the number of fins to generate.</span>
<span class="sd">            depth: A number for the depth to extrude the fins.</span>
<span class="sd">            offset: A number for the distance to offset fins from this face.</span>
<span class="sd">                Default is 0 for no offset.</span>
<span class="sd">            angle: A number for the for an angle to rotate the fins in radians.</span>
<span class="sd">                Default is 0 for no rotation.</span>
<span class="sd">            contour_vector: A Vector3D for the direction along which contours</span>
<span class="sd">                are generated. Default is Z-Axis, which generates horizontal fins.</span>
<span class="sd">            flip_side: Boolean to note whether the side the fins start from</span>
<span class="sd">                should be flipped. Default is False to have contours on top or right.</span>
<span class="sd">                Setting to True will start contours on the bottom or left.</span>
<span class="sd">            tolerance: An optional value to remove any contours with a length less</span>
<span class="sd">                than the tolerance. Default is 0, which will include all contour fins</span>
<span class="sd">                no matter how small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extru_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fin_extrusion_vector</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contour_vector</span><span class="p">)</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">countour_by_number</span><span class="p">(</span>
            <span class="n">fin_count</span><span class="p">,</span> <span class="n">contour_vector</span><span class="p">,</span> <span class="n">flip_side</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extrusion_fins</span><span class="p">(</span><span class="n">contours</span><span class="p">,</span> <span class="n">extru_vec</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="Face3D.countour_fins_by_distance_between"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.countour_fins_by_distance_between">[docs]</a>    <span class="k">def</span> <span class="nf">countour_fins_by_distance_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                          <span class="n">contour_vector</span><span class="o">=</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                          <span class="n">flip_side</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a list of Fac3D objects over this face (like louvers or fins).</span>

<span class="sd">        Args:</span>
<span class="sd">            distance: A number for the approximate distance between each contour.</span>
<span class="sd">            depth: A number for the depth to extrude the fins.</span>
<span class="sd">            offset: A number for the distance to offset fins from this face.</span>
<span class="sd">                Default is 0 for no offset.</span>
<span class="sd">            angle: A number for the for an angle to rotate the fins in radians.</span>
<span class="sd">                Default is 0 for no rotation.</span>
<span class="sd">            contour_vector: A Vector3D for the direction along which contours</span>
<span class="sd">                are generated. Default is Z-Axis, which generates horizontal fins.</span>
<span class="sd">            flip_side: Boolean to note whether the side the fins start from</span>
<span class="sd">                should be flipped. Default is False to have contours on top or right.</span>
<span class="sd">                Setting to True will start contours on the bottom or left.</span>
<span class="sd">            tolerance: An optional value to remove any contours with a length less</span>
<span class="sd">                than the tolerance. Default is 0, which will include all contour fins</span>
<span class="sd">                no matter how small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extru_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fin_extrusion_vector</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contour_vector</span><span class="p">)</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">countour_by_distance_between</span><span class="p">(</span>
            <span class="n">distance</span><span class="p">,</span> <span class="n">contour_vector</span><span class="p">,</span> <span class="n">flip_side</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extrusion_fins</span><span class="p">(</span><span class="n">contours</span><span class="p">,</span> <span class="n">extru_vec</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="Face3D.sub_faces_by_ratio"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.sub_faces_by_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">sub_faces_by_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of faces with a combined area equal to the ratio times this face area.</span>

<span class="sd">        All sub faces will lie inside the boundaries of this face.</span>

<span class="sd">        Args:</span>
<span class="sd">            ratio: A number between 0 and 1 for the ratio between the area of</span>
<span class="sd">                the sub faces and the area of this face.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Face3D objects for sub faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">ratio</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_convex</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_tri_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangulated_mesh3d</span>
            <span class="n">_tri_faces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">_tri_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">_tri_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">]</span>
            <span class="n">_scaled_verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_tri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_tri_faces</span><span class="p">):</span>
                <span class="n">_scaled_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">,</span> <span class="n">_tri_mesh</span><span class="o">.</span><span class="n">face_centroids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">_tri</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">(</span><span class="n">_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span> <span class="k">for</span> <span class="n">_t</span> <span class="ow">in</span> <span class="n">_scaled_verts</span><span class="p">]</span></div>

<div class="viewcode-block" id="Face3D.sub_faces_by_ratio_rectangle"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.sub_faces_by_ratio_rectangle">[docs]</a>    <span class="k">def</span> <span class="nf">sub_faces_by_ratio_rectangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of faces with a combined area equal to the ratio times this face area.</span>

<span class="sd">        This function is virtually equivalent to the sub_faces_by_ratio method</span>
<span class="sd">        but a check will be performed to see if any rectangles can be pulled out</span>
<span class="sd">        of this face&#39;s geometry. This tends to make the result a bit cleaner,</span>
<span class="sd">        especially for concave faces that have rectangles (like L-shaped faces).</span>

<span class="sd">        Args:</span>
<span class="sd">            ratio: A number between 0 and 1 for the ratio between the area of</span>
<span class="sd">                the sub faces and the area of this face.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered a part of a rectangle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Face3D objects for sub faces. If there is a rectangle in this</span>
<span class="sd">            shape, the scaled rectangle will be the first item in this list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rect_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_rectangle</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rect_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_faces_by_ratio</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
        <span class="n">bottom_seg</span><span class="p">,</span> <span class="n">top_seg</span><span class="p">,</span> <span class="n">other_faces</span> <span class="o">=</span> <span class="n">rect_res</span>
        <span class="n">rect_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">((</span><span class="n">bottom_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">bottom_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">top_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">top_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">ratio</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">sub_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">rect_face</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">,</span> <span class="n">rect_face</span><span class="o">.</span><span class="n">center</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">other_faces</span><span class="p">:</span>
            <span class="n">sub_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">sub_faces_by_ratio</span><span class="p">(</span><span class="n">ratio</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sub_faces</span></div>

<div class="viewcode-block" id="Face3D.sub_faces_by_ratio_sub_rectangle"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.sub_faces_by_ratio_sub_rectangle">[docs]</a>    <span class="k">def</span> <span class="nf">sub_faces_by_ratio_sub_rectangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">sub_rect_height</span><span class="p">,</span> <span class="n">sill_height</span><span class="p">,</span>
                                         <span class="n">horizontal_separation</span><span class="p">,</span> <span class="n">vertical_separation</span><span class="p">,</span>
                                         <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of faces with a combined area equal to the ratio times this face area.</span>

<span class="sd">        This function is virtually equivalent to the sub_faces_by_ratio_rectangle</span>
<span class="sd">        method but any rectangles that are found will be broken down into sub-rectangles</span>
<span class="sd">        using the other inputs (sub_rect_height, sill_height, horizontal_separation,</span>
<span class="sd">        vertical_separation). This allows for the creation of a wide array of</span>
<span class="sd">        rectangular sub-face geometries.</span>

<span class="sd">        Args:</span>
<span class="sd">            ratio: A number between 0 and 1 for the ratio between the area of</span>
<span class="sd">                the sub faces and the area of this face.</span>
<span class="sd">            sub_rect_height: A number for the target height of the output sub-</span>
<span class="sd">                rectangles. Note that, if the ratio is too large for the height,</span>
<span class="sd">                the ratio will take precedence and the sub-rectangle height will</span>
<span class="sd">                be larger than this value.</span>
<span class="sd">            sill_height: A number for the target height above the bottom edge of</span>
<span class="sd">                the rectangle to start the sub-rectangles. Note that, if the</span>
<span class="sd">                ratio is too large for the height, the ratio will take precedence</span>
<span class="sd">                and the sub-rectangle height will be smaller than this value.</span>
<span class="sd">            horizontal_separation: A number for the target separation between</span>
<span class="sd">                individual sub-rectangle centerlines.  If this number is larger than</span>
<span class="sd">                the parent rectangle base, only one sub-rectangle will be produced.</span>
<span class="sd">            vertical_separation: An optional number to create a single vertical</span>
<span class="sd">                separation between top and bottom sub-rectangles. The default is</span>
<span class="sd">                0 for no separation.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered a part of a rectangle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Face3D objects for sub faces. If there is a rectangle in this</span>
<span class="sd">            shape, the scaled rectangle will be the first item in this list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rect_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_rectangle</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rect_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_faces_by_ratio</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
        <span class="n">bottom_seg</span><span class="p">,</span> <span class="n">top_seg</span><span class="p">,</span> <span class="n">other_faces</span> <span class="o">=</span> <span class="n">rect_res</span>
        <span class="n">height_seg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">bottom_seg</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">top_seg</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="n">base_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">bottom_seg</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">bottom_seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="n">sub_faces</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">sub_rectangles_from_rectangle</span><span class="p">(</span>
            <span class="n">base_plane</span><span class="p">,</span> <span class="n">bottom_seg</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">height_seg</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span>
            <span class="n">sub_rect_height</span><span class="p">,</span> <span class="n">sill_height</span><span class="p">,</span> <span class="n">horizontal_separation</span><span class="p">,</span> <span class="n">vertical_separation</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">other_faces</span><span class="p">:</span>
            <span class="n">sub_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">sub_faces_by_ratio</span><span class="p">(</span><span class="n">ratio</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sub_faces</span></div>

<div class="viewcode-block" id="Face3D.get_top_bottom_horizontal_edges"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.get_top_bottom_horizontal_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_top_bottom_horizontal_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get top and bottom horizontal edges of this Face if they exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The maximum difference between the z values of the start and</span>
<span class="sd">                end coordinates at which an edge is considered horizontal.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bottom_edge, top_edge) with each as LineSegment3D if they exist.</span>
<span class="sd">            None if they do not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test if each of the edges are vertical.</span>
        <span class="n">horizontal_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">(</span><span class="n">tolerance</span><span class="p">):</span>
                <span class="n">horizontal_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">horizontal_edges</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">horizontal_edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Face3D.get_left_right_vertical_edges"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.get_left_right_vertical_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_left_right_vertical_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get left and right vertical edges of this Face if they exist.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The maximum difference between the x any y values of the start</span>
<span class="sd">                and end coordinates at which an edge is considered vertical.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (left_edge, right_edge) with each as LineSegment3D if they exist. Left in</span>
<span class="sd">            this case is defined as the edge with the lower X coordinates.</span>
<span class="sd">            Result will be None if vertical edges do not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test if each of the edges are vertical.</span>
        <span class="n">vertical_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_vertical</span><span class="p">(</span><span class="n">tolerance</span><span class="p">):</span>
                <span class="n">vertical_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertical_edges</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vertical_edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vertical_edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Face3D.extract_rectangle"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.extract_rectangle">[docs]</a>    <span class="k">def</span> <span class="nf">extract_rectangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract top and bottom line segments of a rectangle within this Face.</span>

<span class="sd">        This method will only return geometry if:</span>

<span class="sd">        1)  There are no holes in the face.</span>

<span class="sd">        2)  The face is not parallel to the World XY plane.</span>

<span class="sd">        3)  There are two parallel edges to this face, which are either</span>
<span class="sd">            oriented horizontally or vertically.</span>

<span class="sd">        4)  There must be enough overlap between these edges for a rectangle</span>
<span class="sd">            to be drawn between them.</span>

<span class="sd">        If this Face does not satisfy this criteria, None will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered a part of a rectangle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with three elements</span>

<span class="sd">            -   bottom_edge: A LineSegment3D representing the bottom of the rectangle.</span>

<span class="sd">            -   top_edge: A LineSegment3D representing the top of the rectangle.</span>

<span class="sd">            -   other_faces:</span>
<span class="sd">                A list of Face3D objects for the parts of this face not</span>
<span class="sd">                included in the rectangle. The length of this list will be between</span>
<span class="sd">                0 (if this face is already rectangular) and 2 (if there are non-</span>
<span class="sd">                rectangular geometries on either side of the rectangle.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># perform checks on the face to see if a rectangle is extractable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="c1"># face lies within a horizontal plane; we cannot distinguish top and bottom</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">clean_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># try to extract a rectangle from horizontal curves</span>
        <span class="n">horiz_result</span> <span class="o">=</span> <span class="n">clean_face</span><span class="o">.</span><span class="n">get_top_bottom_horizontal_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">horiz_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bottom_seg</span><span class="p">,</span> <span class="n">top_seg</span> <span class="o">=</span> <span class="n">horiz_result</span>
            <span class="n">split_res</span> <span class="o">=</span> <span class="n">clean_face</span><span class="o">.</span><span class="n">_split_with_rectangle</span><span class="p">(</span><span class="n">bottom_seg</span><span class="p">,</span> <span class="n">top_seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">split_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]),</span> \
                    <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> \
                    <span class="n">split_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># try to extract a rectangle from vertical curves</span>
        <span class="n">vert_result</span> <span class="o">=</span> <span class="n">clean_face</span><span class="o">.</span><span class="n">get_left_right_vertical_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vert_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left_seg</span><span class="p">,</span> <span class="n">right_seg</span> <span class="o">=</span> <span class="n">vert_result</span>
            <span class="n">split_res</span> <span class="o">=</span> <span class="n">clean_face</span><span class="o">.</span><span class="n">_split_with_rectangle</span><span class="p">(</span><span class="n">left_seg</span><span class="p">,</span> <span class="n">right_seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">split_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seg_1</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">seg_2</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">split_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">seg_1</span><span class="p">,</span> <span class="n">seg_2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">split_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Face3D.sub_rectangles_from_rectangle"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.sub_rectangles_from_rectangle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sub_rectangles_from_rectangle</span><span class="p">(</span><span class="n">base_plane</span><span class="p">,</span> <span class="n">parent_base</span><span class="p">,</span> <span class="n">parent_height</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span>
                                      <span class="n">sub_rect_height</span><span class="p">,</span> <span class="n">sill_height</span><span class="p">,</span>
                                      <span class="n">horizontal_separation</span><span class="p">,</span> <span class="n">vertical_separation</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of rectangular Face3D objects using parameters to define them.</span>

<span class="sd">        All of the resulting Face3D objects lie within a parent rectangle defined</span>
<span class="sd">        by the parent_base, parent_height, and base_plane. The combined area of the</span>
<span class="sd">        resulting rectangles is equal to the area of the larger rectangle multiplied</span>
<span class="sd">        by the input ratio. This method is particularly useful for generating</span>
<span class="sd">        rectangular window surfaces.</span>

<span class="sd">        Args:</span>
<span class="sd">            parent_base: A number indicating the length of the base of the</span>
<span class="sd">                parent rectangle.</span>
<span class="sd">            parent_height: A number indicating the length of the height of the</span>
<span class="sd">                parent rectangle.</span>
<span class="sd">            ratio: A number between 0 and 1 for the ratio between the area of</span>
<span class="sd">                the sub rectangle faces and the area of this face.</span>
<span class="sd">            sub_rect_height: A number for the target height of the output sub-</span>
<span class="sd">                rectangles. Note that, if the ratio is too large for the height,</span>
<span class="sd">                the ratio will take precedence and the sub-rectangle height will</span>
<span class="sd">                be larger than this value.</span>
<span class="sd">            sill_height: A number for the target height above the bottom edge of</span>
<span class="sd">                the rectangle to start the sub-rectangles. Note that, if the</span>
<span class="sd">                ratio is too large for the height, the ratio will take precedence</span>
<span class="sd">                and the sub-rectangle height will be smaller than this value.</span>
<span class="sd">            horizontal_separation: A number for the target separation between</span>
<span class="sd">                individual sub-rectangle centerlines.  If this number is larger than</span>
<span class="sd">                the parent rectangle base, only one sub-rectangle will be produced.</span>
<span class="sd">            vertical_separation: An optional number to create a single vertical</span>
<span class="sd">                separation between top and bottom sub-rectangles. The default is</span>
<span class="sd">                0 for no separation.</span>
<span class="sd">            base_plane: A Plane object in which the rectangle exists.</span>
<span class="sd">                The origin of this plane will be the lower left corner of the</span>
<span class="sd">                rectangle and the X and Y axes will form the sides.</span>
<span class="sd">                Default is the world XY plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate the target area to make the combined sub-rectangles</span>
        <span class="n">target_area</span> <span class="o">=</span> <span class="n">parent_base</span> <span class="o">*</span> <span class="n">parent_height</span> <span class="o">*</span> <span class="n">ratio</span>
        <span class="c1"># find the maximum area for subdivision into smaller, taller sub-rectangles</span>
        <span class="n">max_area_subdiv</span> <span class="o">=</span> <span class="n">parent_base</span> <span class="o">*</span> <span class="mf">0.98</span> <span class="o">*</span> <span class="n">sub_rect_height</span>
        <span class="c1"># if sub_rect_height &gt; parent_height, set it to just under parent_height</span>
        <span class="n">max_subh</span> <span class="o">=</span> <span class="mf">0.98</span> <span class="o">*</span> <span class="n">parent_height</span>
        <span class="n">sub_rect_height</span> <span class="o">=</span> <span class="n">max_subh</span> <span class="k">if</span> <span class="n">sub_rect_height</span> <span class="o">&gt;</span> <span class="n">max_subh</span> <span class="k">else</span> <span class="n">sub_rect_height</span>
        <span class="c1"># if sill_height is close to 0, set it to just above 0.</span>
        <span class="n">min_sill</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">parent_height</span>
        <span class="n">sill_height</span> <span class="o">=</span> <span class="n">min_sill</span> <span class="k">if</span> <span class="n">sill_height</span> <span class="o">&lt;</span> <span class="n">min_sill</span> <span class="k">else</span> <span class="n">sill_height</span>
        <span class="c1"># properties used throughout the computation of sub-rectangles</span>
        <span class="n">bottom_seg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_sdl</span><span class="p">(</span><span class="n">base_plane</span><span class="o">.</span><span class="n">o</span><span class="p">,</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">parent_base</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target_area</span> <span class="o">&lt;</span> <span class="n">max_area_subdiv</span><span class="p">:</span>
            <span class="c1"># divide up the rectangle into points on the bottom.</span>
            <span class="k">if</span> <span class="n">parent_base</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">horizontal_separation</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">num_div</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">parent_base</span> <span class="o">/</span> <span class="n">horizontal_separation</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_div</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">btm_div_pts</span> <span class="o">=</span> <span class="n">bottom_seg</span><span class="o">.</span><span class="n">subdivide_evenly</span><span class="p">(</span><span class="n">num_div</span><span class="p">)</span>
            <span class="n">btm_div_segs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">btm_div_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">btm_div_pts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1"># move the segments to the sill height</span>
            <span class="n">max_sill_h</span> <span class="o">=</span> <span class="n">parent_height</span> <span class="o">*</span> <span class="mf">0.99</span> <span class="o">-</span> <span class="n">sub_rect_height</span>
            <span class="n">sill_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">sill_height</span> <span class="k">if</span> <span class="n">sill_height</span> <span class="o">&lt;</span> <span class="n">max_sill_h</span> \
                <span class="k">else</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">max_sill_h</span>
            <span class="n">div_segs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">sill_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">btm_div_segs</span><span class="p">)</span>
            <span class="c1"># scale the segments along their center points</span>
            <span class="n">seg_width</span> <span class="o">=</span> <span class="n">div_segs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length</span>
            <span class="n">subrect_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="n">sub_rect_height</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_div</span>
            <span class="n">scale_fac</span> <span class="o">=</span> <span class="n">subrect_width</span> <span class="o">/</span> <span class="n">seg_width</span>
            <span class="n">scaled_segs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale_fac</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">midpoint</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">div_segs</span><span class="p">]</span>
            <span class="c1"># find the maximum acceptable area for splitting the glazing vertically.</span>
            <span class="k">if</span> <span class="n">vertical_separation</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max_split_vert</span> <span class="o">=</span> <span class="n">parent_height</span> <span class="o">-</span> <span class="n">sill_height</span> <span class="o">-</span> <span class="n">sub_rect_height</span> \
                    <span class="o">-</span> <span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">parent_height</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vertical_separation</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">max_split_vert</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">vertical_separation</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">vertical_separation</span> <span class="o">&gt;</span> <span class="n">max_split_vert</span><span class="p">:</span>
                    <span class="n">vertical_separation</span> <span class="o">=</span> <span class="n">max_split_vert</span>
            <span class="c1"># generate the vertices by &#39;extruding&#39; along a window height vector.</span>
            <span class="n">final_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">vertical_separation</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sub_rect_height</span> <span class="o">=</span> <span class="n">sub_rect_height</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">h_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">sub_rect_height</span>
                <span class="n">vert_move_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">sub_rect_height</span> <span class="o">+</span> <span class="n">vertical_separation</span><span class="p">)</span>
                <span class="n">vert_segs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vert_move_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">scaled_segs</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">scaled_segs</span> <span class="o">+</span> <span class="n">vert_segs</span><span class="p">:</span>
                    <span class="n">final_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">),</span> <span class="n">base_plane</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">sub_rect_height</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">scaled_segs</span><span class="p">:</span>
                    <span class="n">final_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">),</span> <span class="n">base_plane</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make a single sub-rectangle at an apporporate sill height</span>
            <span class="n">max_sill_h</span> <span class="o">=</span> <span class="n">parent_height</span> <span class="o">*</span> <span class="mf">0.99</span> <span class="o">-</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">parent_base</span> <span class="o">*</span> <span class="mf">0.98</span><span class="p">))</span>
            <span class="n">sill_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">sill_height</span> <span class="k">if</span> <span class="n">sill_height</span> <span class="o">&lt;</span> <span class="n">max_sill_h</span> \
                <span class="k">else</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">max_sill_h</span>
            <span class="n">seg_init</span> <span class="o">=</span> <span class="n">bottom_seg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">sill_vec</span><span class="p">)</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">seg_init</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">seg_init</span><span class="o">.</span><span class="n">midpoint</span><span class="p">)</span>
            <span class="c1"># find the maximum acceptable area for splitting the glazing vertically.</span>
            <span class="k">if</span> <span class="n">vertical_separation</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max_split_vert</span> <span class="o">=</span> <span class="n">parent_height</span> <span class="o">-</span> <span class="n">sill_height</span> <span class="o">-</span> \
                    <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">parent_base</span> <span class="o">*</span> <span class="mf">0.98</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">parent_height</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vertical_separation</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">max_split_vert</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">vertical_separation</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">vertical_separation</span> <span class="o">&gt;</span> <span class="n">max_split_vert</span><span class="p">:</span>
                    <span class="n">vertical_separation</span> <span class="o">=</span> <span class="n">max_split_vert</span>
            <span class="c1"># generate the vertices by &#39;extruding&#39; along a window height vector.</span>
            <span class="k">if</span> <span class="n">vertical_separation</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sub_rect_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">parent_base</span> <span class="o">*</span> <span class="mf">0.98</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">h_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">sub_rect_height</span>
                <span class="n">vert_move_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">sub_rect_height</span> <span class="o">+</span> <span class="n">vertical_separation</span><span class="p">)</span>
                <span class="n">vert_seg</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vert_move_vec</span><span class="p">)</span>
                <span class="n">final_faces</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">seg</span><span class="p">,</span> <span class="n">vert_seg</span><span class="p">]:</span>
                    <span class="n">final_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">),</span> <span class="n">base_plane</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_vec</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">parent_base</span> <span class="o">*</span> <span class="mf">0.98</span><span class="p">))</span>
                <span class="n">final_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">((</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">),</span>
                                      <span class="n">base_plane</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">final_faces</span></div>

<div class="viewcode-block" id="Face3D.to_dict"><a class="viewcode-back" href="../../../ladybug_geometry.geometry3d.face.html#ladybug_geometry.geometry3d.face.Face3D.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_plane</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enforce_upper_left</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get Face3D as a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            include_plane: Set to True to include the Face3D plane in the</span>
<span class="sd">                dictionary, which will preserve the underlying orientation</span>
<span class="sd">                of the face plane. Default True.</span>
<span class="sd">            enforce_upper_left: Set to True to ensure that the boundary vertices all</span>
<span class="sd">                start from the upper-left corner. This takes extra time to compute but</span>
<span class="sd">                ensures that the vertices in the dictionary are directly usable in an</span>
<span class="sd">                EnergyPlus simulations. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Face3D&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">enforce_upper_left</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">upper_left_counter_clockwise_boundary</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">include_plane</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;plane&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;holes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">base</span></div>

    <span class="k">def</span> <span class="nf">_check_vertices_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">loop_name</span><span class="o">=</span><span class="s1">&#39;boundary&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;There must be at least 3 vertices for a Face3D </span><span class="si">{}</span><span class="s1">.&#39;</span> \
            <span class="s1">&#39; Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">loop_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vert</span><span class="p">,</span> <span class="n">Point3D</span><span class="p">),</span> \
                <span class="s1">&#39;Expected Point3D for Face3D </span><span class="si">{}</span><span class="s1"> vertex. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">loop_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">vert</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vertices</span>

    <span class="k">def</span> <span class="nf">_check_number_mesh_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)),</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> for Face3D.get_mesh_grid&#39;</span> \
            <span class="s1">&#39; must be a number. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">mov_vec</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">mov_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rotate_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reflect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_face_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform face in a way that transfers properties and avoids checks.&quot;&quot;&quot;</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfer_properties</span><span class="p">(</span><span class="n">_new_face</span><span class="p">)</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_mesh2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh2d</span>
        <span class="k">return</span> <span class="n">_new_face</span>

    <span class="k">def</span> <span class="nf">_face_transform_reflect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reflect face in a way that transfers properties and avoids checks.&quot;&quot;&quot;</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfer_properties</span><span class="p">(</span><span class="n">_new_face</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span>

    <span class="k">def</span> <span class="nf">_face_transform_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale face in a way that transfers properties and avoids checks.&quot;&quot;&quot;</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfer_properties_scale</span><span class="p">(</span><span class="n">_new_face</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new_face</span>

    <span class="k">def</span> <span class="nf">_transfer_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_face</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transfer properties from this face to a new face.</span>

<span class="sd">        This is used by the transform methods that don&#39;t alter the relationship of</span>
<span class="sd">        face vertices to one another (move, rotate, reflect).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_face</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span>
        <span class="n">new_face</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area</span>
        <span class="n">new_face</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_convex</span>
        <span class="n">new_face</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_self_intersecting</span>

    <span class="k">def</span> <span class="nf">_transfer_properties_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_face</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transfer properties from this face to a new face.</span>

<span class="sd">        This is used by the methods that scale the face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_face</span><span class="o">.</span><span class="n">_is_convex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_convex</span>
        <span class="n">new_face</span><span class="o">.</span><span class="n">_is_self_intersecting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_self_intersecting</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_face</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perimeter</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_face</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_calculate_min_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate maximum and minimum Point3D for this object.&quot;&quot;&quot;</span>
        <span class="n">min_pt</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>
        <span class="n">max_pt</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">min_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">max_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">max_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">min_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">min_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">max_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">max_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">min_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">min_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">max_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">max_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_min</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">min_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">max_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_remove_colinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove colinear vertices from a list of Point2D.</span>

<span class="sd">        This method determines colinearity by checking whether the area of the</span>
<span class="sd">        triangle formed by 3 vertices is less than the tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_vertices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">):</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                <span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">_v</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_vertices</span>

    <span class="k">def</span> <span class="nf">_vertices_between_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_pt</span><span class="p">,</span> <span class="n">end_pt</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the vertices between a start and end point.</span>

<span class="sd">        This method is used by the extract_rectangle method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_pt</span><span class="p">]</span>
        <span class="n">vert_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start_pt</span><span class="p">)</span>
        <span class="n">found_other</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="n">found_other</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">vert_ind</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">new_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">vert_ind</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">vert_ind</span><span class="p">]</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">end_pt</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="n">found_other</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">new_verts</span>

    <span class="k">def</span> <span class="nf">_get_fin_extrusion_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contour_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the vector with which to extrude fins.&quot;&quot;&quot;</span>
        <span class="n">extru_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">depth</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">contour_vector</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">contour_vector</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="n">contour_vector</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">contour_vector</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">extru_vec</span> <span class="o">=</span> <span class="n">extru_vec</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extru_vec</span>

    <span class="k">def</span> <span class="nf">_get_extrusion_fins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">extru_vec</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get fins from the contours and extrusion vector.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">off_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">offset</span>
            <span class="n">contours</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">off_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">extru_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_split_with_rectangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_1</span><span class="p">,</span> <span class="n">edge_2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split this shape using two parallel edges of the face.</span>

<span class="sd">        Result will be None if no rectangle can be obtained.</span>

<span class="sd">        Returns:</span>
<span class="sd">            rectangle_points: A tuple of 4 points that make the rectangle.</span>
<span class="sd">            other_faces: A list of faces for the other parts of this Face that</span>
<span class="sd">                are not a part of the rectangle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute the 4 points defining the rectangle</span>
        <span class="n">close_pt_1</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_2</span><span class="p">)</span>
        <span class="n">close_pt_2</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">edge_1</span><span class="p">)</span>
        <span class="n">close_pt_3</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">edge_2</span><span class="p">)</span>
        <span class="n">close_pt_4</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_1</span><span class="p">)</span>

        <span class="c1"># check that there is overlap between the top and bottom curves</span>
        <span class="k">if</span> <span class="n">close_pt_1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">close_pt_3</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># check that the two sides of the rectangle are inside the polygon.</span>
        <span class="n">mid_pt_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span>
            <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">close_pt_1</span><span class="p">,</span> <span class="n">close_pt_2</span><span class="p">)</span><span class="o">.</span><span class="n">midpoint</span><span class="p">)</span>
        <span class="n">mid_pt_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span>
            <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">close_pt_3</span><span class="p">,</span> <span class="n">close_pt_4</span><span class="p">)</span><span class="o">.</span><span class="n">midpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">mid_pt_1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">mid_pt_2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># get extra faces outside of the rectangle</span>
        <span class="n">other_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_pts_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices_between_points</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">close_pt_1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">edge_pts_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt_1</span><span class="p">)</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">edge_pts_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">close_pt_2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">edge_pts_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt_2</span><span class="p">)</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">edge_pts_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_pts_1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">edge_pts_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">))</span>

        <span class="n">edge_pts_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices_between_points</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">close_pt_3</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">edge_pts_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt_3</span><span class="p">)</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">edge_pts_2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">close_pt_4</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">edge_pts_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt_4</span><span class="p">)</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">edge_pts_2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_pts_2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">edge_pts_2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">))</span>

        <span class="c1"># check that any new faces are not self intersecting</span>
        <span class="k">for</span> <span class="n">new_face</span> <span class="ow">in</span> <span class="n">other_faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_face</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># return the rectangle edges and the extra faces</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">close_pt_1</span><span class="p">,</span> <span class="n">close_pt_2</span><span class="p">,</span> <span class="n">close_pt_3</span><span class="p">,</span> <span class="n">close_pt_4</span><span class="p">),</span> <span class="n">other_faces</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_plane_from_vertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a plane from a list of non-colinear vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            vertices: The vertices to be used to extract the normal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># walk around the whole shape to avoid colinear vertices</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">_normal_from_3pts</span><span class="p">(</span><span class="o">*</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
                <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span>
                <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">z</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect vertices input for Face3D:</span><span class="se">\n\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_normal_from_3pts</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a tuple representing a normal vector from 3 vertices.</span>

<span class="sd">        The vector will have a magnitude of 0 if vertices are colinear.</span>
<span class="sd">        This method effectively performs the cross product of two vectors but</span>
<span class="sd">        the ladybug_geometry objects are not used in order to remove assertions</span>
<span class="sd">        and increase speed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt2</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pt1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt2</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pt1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt2</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">pt1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt3</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pt1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt3</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pt1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt3</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">pt1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="o">-</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_corner_pt_verts</span><span class="p">(</span><span class="n">corner_pt</span><span class="p">,</span> <span class="n">verts3d</span><span class="p">,</span> <span class="n">verts2d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get verts3d starting from the one closes to the corner_pt.&quot;&quot;&quot;</span>
        <span class="n">first_pt_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">verts2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">corner_pt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pt_index</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">verts2d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">new_dist</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">corner_pt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                <span class="n">first_pt_index</span> <span class="o">=</span> <span class="n">pt_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">new_dist</span>
        <span class="k">if</span> <span class="n">first_pt_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">verts3d</span> <span class="o">=</span> <span class="n">verts3d</span><span class="p">[</span><span class="n">first_pt_index</span><span class="p">:]</span> <span class="o">+</span> <span class="n">verts3d</span><span class="p">[:</span><span class="n">first_pt_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">verts3d</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_new_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfer_properties</span><span class="p">(</span><span class="n">_new_face</span><span class="p">)</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holes</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_polygon2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygon2d</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_mesh2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh2d</span>
        <span class="n">_new_face</span><span class="o">.</span><span class="n">_mesh3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh3d</span>
        <span class="k">return</span> <span class="n">_new_face</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Face3D (</span><span class="si">{}</span><span class="s1"> vertices)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019, Ladybug Tools.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.<br/>
    </p>
  </div>
</footer>
  </body>
</html>